##1.布控逻辑
### 1.1）paas-vcs版本
* 注：预警结果是通过kafka consumer 消费入库mysql

#####      1)CREATE
            1.1)WarnDetailApi#addDetail //单个布控
                1.1.2)从数据库配置表 t_config.warn_service_instance 获取实现类service name
                1.1.3)初始化status为0（0：初始化，1：启动成功，2：启动中）
                1.1.4)warnService#insertWarnBO 。数据入库：先将车牌号、人脸图片上传到存储服务器后的url存储到t_warning_person的car_no,image_base 中；获取到自增id，存储在布控主表warning_detail.target_id
                1.1.5)更新用户默认置信度：confUserBusinessService#updateConfigByUsername
                1.1.6）if(status==1&&入库成功)->WarnDetailApi#changeWarnStatus
                1.1.7）if(启动任务失败)->WarnDetailApi#delDetail
            1.2）batchAddAndStartWarnTask //新增并开启批量人脸布控
                1）判断并发数量，最大支持4并发
                2）判断文件后缀，必须是zip的
                3）计算出文件的md5，并设置为warning_detail.target_id
                4）warnCommonUtil#getBatchWarnServiceInstance //根据t_config.batch_warn_service_instance 获取批量布控对应的实现类对象
                5）batchWarnService.insertWarnBO
                    5.1）warningDetailMapper#insert //主任务布控入库表warning_detail，status标记为2
                    5.2)executorService.submit(new BatchWarnTaskManage(warningDetail, destPath, warningDetail.getUserId()))  //利用多线程进行批量布控的操作，同时异步返回“布控进行中”
                        5.2.1）通过applicationContext获取所需bean
                        5.2.2）uploadToOss //解析图片zip压缩包，后将图片全部上传到oss上，并将url及图片信息封装到对应的WarnDetailBO中，放入warnDetailVOQueue队列中
                        5.2.3）consumeWarnDetailVO //调用vcs创建布控结果口，获task_id。将上一步封装的对象信息，全部插入到detail/t_warning_person/yw_warn_task_record 三张表中。
                        5.2.3)batchWarnService#startWarnById //调用批量布控实现类更新布控底库，每次更新图片张数由配置项t_config.updateWarnCameraListLimitCount 确定，默认100
                        5.2.4)根据响应的图片入库情况，更新布控记录表yw_warn_task_record,布控主表warning_detail
#####      2)UPDATE
            2.1)入口：WarnDetailApi#updateDetail
                1)warnService#updateWarnBO//更新布控
                    a)参数校验
                    b)if(!"confidenceLevel".equals(type))->上传人脸图片到存储服务器，并将url存入t_warning_person,获取更新的自增id warningDetailPerson#insertPerson
                  if("confidenceLevel".equals(type))->不执行这个步骤
                    c)将b中获取的id存入warning_detail.target_id
                2）confUserBusinessService#updateConfigByUsername//更新用户默认置信度
                3）warningDetailMapper#updateById//更新表记录
            2.2）设置置顶（收藏）
                1）warnService.setSortTopByOperateCode //在最大收藏值的基础上递增1

#####      3)RETRIEVE
            3.1）WarnDetailApi#getDetailById(warnService#selectWarnDetailById) //获取单个布控详情
                a)super(chongqing/WarnServiceImpl)#selectWarnDetailById
                b)判断布控类型
                  1)if (TypeConstant.TZ.equals(type) && TabTypeConstant.BATCH_FACE_SUB_DETAIL.equals(tabType) && StringUtils.isNotBlank(id))->warningDetailMapper#selectPersonListByMapInCq
                  2)if (TypeConstant.TZ.equals(type) && StringUtils.containsAny(tabType, TabTypeConstant.PERSON))->
                  warningDetailMapper#selectPPWarnListByEntity
                c)chongqing/WarnServiceImpl#encapsulateSubTabAttributeById //将b中查询到的内容（list只会有一个元素）封装为前端展示的对象
                d)chongqing/WarnServiceImpl#selectWarnResultList //根据id查询出需要的预警结果列表
            3.2)WarnDetailApi#getDetaiList //获取布控任务列表（支持多条件和分页）
                a) expireWarnTaskManager.doClear //自动停止过期布控任务
                b) 判断查询类型：if (StringUtils.isBlank(tabType))->
                默认设置 TabTypeConstant.PERSON + "," + TabTypeConstant.BATCH_FACE
                c) warnService（super）#selectWarnListByQuery //查询布控任务列表
                d) 判断布控类型
                  1)if (TypeConstant.TZ.equals(type) && TabTypeConstant.BATCH_FACE_SUB_DETAIL.equals(tabType) && StringUtils.isNotBlank(id))->warningDetailMapper#selectPersonListByMapInCq
                  2)if (TypeConstant.TZ.equals(type) && StringUtils.containsAny(tabType, TabTypeConstant.PERSON))->
                  warningDetailMapper#selectPPWarnListByEntity
                e)warningDetailMapper#selectDetailListTotal //查询布控任务数据量
                f)chongqing/WarnServiceImpl#encapsulateDetailVO //封装布控任务列表为前端展示对象
#####      4)DELETE
             4.1）WarnDetailApi#delDetail //入口
             4.2)warnService#deleteWarnById //删除布控任务，会将布控主表warning_detail\记录表yw_warn_task_record\结果表ads_szjws_warn_result_spjsxt/信息记录表t_warning_person全部删除
                4.2.1）warningDetailMapper#selectById //根据id查询布控主任务详情
                4.2.1）if(!TabTypeConstant.BATCH_FACE_SUB_DETAIL.equals(warnDetailDOWhole.getTabType()))-> 
                    a)warningDetailMapper#selectByParentWarnId //根据id查询布控主任务详情
                    b)warningPersonMapper#deleteByTargetList //根据条件查询出来的信息记录批量删除(批量布控子任务的)
                    c）warnTaskRecordService#deleteByWarnId //删除布控主表的内容
                4.2.4）warningDetailPerson#delById//删除主任务对应的person记录
                4.2.5）warningDetailMapper#deleteByParentWarnId//根据parentWarnId\warnId删除布控主表

#####      5）START WARN
             5.1)WarnDetailApi#changeWarnStatus(if(status==1))
             5.2)warnService#startWarnById//车牌号布控、人脸布控都是独立的布控任务
                 5.2.1)warningDetailMapper#selectById //根据id查询布控主任务详情
                 5.2.2)参数校验
                 5.2.3)判断布控类型（BATCH_FACE：批量人脸，PERSON：车牌号或单个人脸）
                  3.1）if (TabTypeConstant.BATCH_FACE.equals(tabType))->
                    3.1.1)if (!"0".equals(warningDetail.getStatus()))->当前的批量布控任务正在启动，无法再次开启
                    3.1.2)warningDetailMapper#selectSubTaskPicListByBatchWarnId//判断pid对应的子任务是否有
                    3.1.3)if ("0".equals(warningDetail.getStatus()))->
                        a)warnService#getBatchTaskId//调用第三方接口创建布控滨以获取task_id
                        b)warningDetailMapper#updateById//status设置为2，布控启动中，并更新warning_detail
                        c)executorService#execute(new BatchUpdateWarnPicListTask(warningDetail))//使用多线程，批量更新布控图片
                  3.2）if (TabTypeConstant.PERSON.equals(tabType))->
                    3.2.1)warningPersonMapper#selectByPrimaryKey//根据target_id查询出来需要布控的信息（主要是人脸图片或是车牌号）
                    3.2.2)if (StringUtils.isNotBlank(faceImageBase) && !faceImageBase.equals("[]"))-> warnService#doFaceWarn//封装参数，调用vcs接口进行布控
                    3.2.3)if (StringUtils.isNotBlank(carNo)) ->paasVcsWarnManager#doID //调用vcs接口进行属性布控
                  3.3）if (TabTypeConstant.BATCH_FACE_SUB_DETAIL.equals(tabType))--> 暂时无法对批量布控任务中的单个图片进行布控，请联系管理员
                  3.4)warnCommonUtil#parseTaskListAndSetResult 
                     3.4.1)warnCommonUtil#parseTaskList //解析布控结构对象，更新任务记录信息
                     3.4.2)封装布控结果及其描述
#####      6）STOP WARN
             6.1)WarnDetailApi#changeWarnStatus(if(status==0))
             6.2)warnService#stopWarnById
                 1）warningDetailMapper#selectById //根据id查询布控主任务详情
                 2）判断布控类型，封装查询条件，查找出该主任务id需要停止的task_id
                 3）paasVcsWarnManager#stopWarnByTaskId //循环调用接口停止task_id
                 4）停止成功则更新task_record、warning_detail表状态，否则返回failed

###  1.2）重庆版-vcs(release/chongqing)
 * 注：预警结果是通过stream computer 消费datahub 入库rds的
        1)新增任务CREATE
            1.1）ShWarningDetailApi#addDetail
                1.1.1)setTargetDd //设置默认布控范围
                1.1.2）从配置表获取布控版本t_config.warn_version
                1.1.3)warningDetailService#insert //调用service 添加布控信息接口
                1.1.4)warningDetailService#choseTz
                    a)判断布控类型，只有tabType=person
                    b)warningDetailPerson#insertPerson //布控图片、车牌号入库
                    c)shWarningDetailMapper#insert //c中id存储target_id并入库
            1.2）ShWarningDetailApi#batchAddAndStartWarnTask //批量布控
                1.2.1）将布控图片zip压缩包进行md5计算，并放置入target_id。将zip存入指定服务器路径
                1.2.2）cqWarningDetailV2Service#batchAddWarnDetail 
                    1.2.2.1）shWarningDetailMapper.insert //此时就默认开启批量布控挂了，主任务入库表warning_detail
                    1.2.2.1）executorService.submit(new BatchWarnTaskManage(warningDetail, destPath, warningDetail.getUserId())) 
                1.2.3)new BatchWarnTaskManage //通过applicationContext获取batchWarnTaskManage所需
                1.2.4）uploadToOss //解析图片zip压缩包，后将图片全部上传到oss上，并将url及图片信息封装到对应的WarnDetailBO中，oss图片名uuid作为warning_detail 的id，放入warnDetailVOQueue队列中
                1.2.5）consumeWarnDetailVO //调用vcs创建布控结果口，获task_id。将上一步封装的对象信息，全部插入到detail/t_warning_person/yw_warn_task_record 三张表中。
                1.2.6)batchWarnService#startWarnById //调用批量布控实现类更新布控底库，每次更新图片张数由配置项t_config.updateWarnCameraListLimitCount 确定，默认100。与paas版vcs区别：该接口为异步，不会及时响应图片处理结果
                1.2.7)vcs会回调接口ShWarningDetailApi#updateProgressForVCS,将图片入库情况返回，更新布控记录表yw_warn_task_record,布控主表warning_detail

        2）修改任务UPDATE（略）
        3）查询任务信息RETRIEVE（略）
        4）删除任务 DELETE（略）
###  1.3）黄浦vcs\黄浦依图
        和paas版本一致，只是调用第三方接口有vcs调整为:车牌号-vcs,人脸布控-依图，无批量人脸布控.
*注：依图的代理地址，使用接口ImageProxyApi#imgUrlProxyForYiTu 依图url图片访问参数已经在stream computer中拼接完成。接口请求文档请查看 黄埔中脑-依图接口文档_20190415.pdf

##2.VS视频播放（最新的为chongqing版）
      2.1）VideoPlayApi#getPlayLiveVideoUrl //获取、封装直播url
        2.1.1）t_config#video_play_is_framed //判断是否进行打框视频播放，这个只有重庆有这种视频直播
        2.1.2）videoPlayUtil#setProtocolByConfig //根据协议配置项t_config.videoPlayLiveProtocol 设置请求播放协议。协议类型https-flv\https-hls\flv\hls .https开头的为重庆https协议所使用的，http协议直播使用flv 点播使用hls
        2.1.3）videoPlayUtil.getSeriveInstance().obtainPlayLiveVideoUrl //根据t_config.videoPlayService 获取播放实现类，并调用service接口
        2.1.4）videoPlayService#getToken //获取vcs鉴权所需token
        2.1.5）videoPlayUtil#excuteQuery //使用httpClient 调用vs接口，获取播放url
        2.1.6）videoPlayUtil#getVideoPlayVO //解析上一步的响应结果Entity，并根据t_config.video_is_proxy判断是否需要添加代理。根据t_config.video_play_live_proxy获取代理地址
     2.2）VideoPlayApi#getPlayHistoryVideoUrl //获取、封装历史播放url
        2.2.1）videoPlayService#obtainPlayLiveVideoUrl //调用直播的接口，获取直播url
        2.2.2）videoPlayUtil#getTimeShiftParamUrl //根据直播偏移参数，拼接点播所使用的偏移query param
        2.2.3）根据t_config.video_is_proxy判断是否需要添加代理。根据t_config.video_play_history_proxy 获取并替换代理地址    

## 3.摄像头查询（略）

##  4.归档合并、导出（根据归档名称作为唯一标识）

​    4.1）ShAnalysisApi#updateArchive //更新归档信息、合并归档
​        4.1.1)if (updateType == VideoResearchConstants.UpdateTypeEnum.MERGE.getTypeCode()) //判断更新类型-覆盖或是合并 。接下来走合并
​        4.1.2）将details（list）转换为以id为key的map对象。然后将新旧两个datails进行合并。
​        4.1.3）if (StringUtils.isBlank(current) && StringUtils.isBlank(oldCurrent)) -> 判断是否为同行布控
​            a) ture：非同行归档。直接赋值details 
​            b) false：同行归档合并，搜索类型必须都是人体或是人脸。setCondition //合并新旧同行归档。分三种情况：单个merge同行，同行merge单个，同行merge同行；
​               同行归档merge后，details需要根据current的值从获取selectedMultipleSearch中对应的value并设置
​    4.2）ShAnalysisApi#dowanloadGdInfo //归档导出
​        4.2.1)ShAnalysisApi#getVideoAndImgExportServiceInstance //根据warn_version判断使用实现类
​        4.2.2)videoAndImgExportService#getVideoZipPathById //根据id获取导出内容下载路径（将图片、文档生成压缩包后，会存储到存储服务器oss/s3），下载时根据配置t_config.oss_url_prefix 拼接代理
​    4.3)归档表存储对象解析：
​            a) details: 当前归档对象列表（一个检索结果图片对应一个对象）
​            a) imgIds:  当前归档的缩略图列表，以";"分隔
​            c) conditions: 非同行归档时，用于存放检索条件；同行归档时，存放对象列表、检索条件等内容
​                c.1) current: 当前展示的归档id(根据图片base64计算的32位md5)，只有同行归档时，才会有值
​                c.2) searchType: 检索类型，正常有：person/face/vehicle/nonvehicle
​                c.3) content: 上传检索人/机/非图片的base64
​                c.4) faceContent: 上传检索人脸图片的base64
​                c.5) selectedMultipleSearch: 同行归档才有该值，map对象，一个key对应同行归档对应一个对象结果列表。
​                c.6) prevImages: 
​                    c.6.1) content: 上传检索人/机/非图片的base64
​                    c.6.2) faceContent: 上传检索人脸图片的base64
​                c.7) keyValue: 同行归档才有该值，map对象，一个key（和selectedMultipleSearch中的key保持一致，为base64计算出来的md5）对应图片base64

