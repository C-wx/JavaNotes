大家好，我是小菜，一个渴望在互联网行业做到蔡不菜的小菜。可柔可刚，点赞则柔，白嫖则刚！
**死鬼~看完记得给我来个三连哦！**


![](https://user-gold-cdn.xitu.io/2020/4/11/17169c46045528af?w=240&h=224&f=jpeg&s=7529)


>本文主要介绍 `分布式事务`
>
>如有需要，可以参考
>
>如有帮助，不忘 **点赞** ❥
>
>
>微信公众号已开启，**小菜良记**，没关注的同学们记得关注哦！

`生活可能对你耍无赖，但科技不行`

我去小卖部买东西，付完了钱，老板转身抽了口烟，却忘记了我付完钱？这种情况怎么办，发生在日常生活并不奇怪。但是你在网上下单，付完了钱，刚要查看订单，却提示你待支付，心中几万只草泥马跑过也不得而知！所以防止这种情况的发生，分布式事务也变得尤为重要。

有人纳闷了，付不付钱跟分布式事务有什么关系，这不是程序耍无赖吗？但是耍无赖的背后却是因为分布式事务在作祟！如果还不明白，那可能你还没明白什么是事务，什么是分布式事务~

### 分布式事务

#### 定义

事务提供一种机制将一个活动涉及的所有操作都纳入到一个不可分割的执行单元，组成事务的祝所有操作只有在操作均正常执行的情况下才能提交，只要其中任一操作执行失败，都会导致整个事务的回滚。简单来说，`要么做，要么不做`。

听起来有点 `man`，不要迷恋，先来了解一下事务的四大特性：`ACID`

- **A（Atomic）**：原子性，构成事物的所有操作，要么全部执行完成，要么全部不执行，不可能出现部分成功部分失败的情况。
- **C（Consistency）**：一致性，在事务执行前后，数据库的一致性约束没有被破坏。一旦所有事务动作完成，事务就被提交，数据和资源处于一种满足业务规则的一致性状态中。比如上面说的，我向商店老板付了钱，我这边扣除了100，而老板增加了100，这种就称为一致性。
- **I（Isolation）**：隔离性，数据库中的事务一般都是并发的，隔离性是指并发的两个事务互不干扰，一个事务不能看到其他事务运行过程的中间状态，通过配置事务隔离级别可以避免在脏读、幻读、不可重复读等问题。
- **D（Durability）**：持久性，事务完成之后，该事务对数据的更改会持久化到数据库中，并且不会被回滚

##### 单体事务

早期我们使用的还是单体架构，像是一个大家族，其乐融融的生活在一起日夜耕作。

![](https://gitee.com/cbuc/picture/raw/master/20210319124841.png)

时间久了，各种各样的问题自然而然的也出现了：`复杂性高，部署频率低，可靠性差，扩展能力受限...` 承受了太多不该承受的流言蜚语，而大家也逐渐找寻新的出路， 那微服务架构也便受应出现：`易于开发、扩展、理解和维护，不会受限于任何技术栈，易于和第三方应用系统集成...` 太多太多的优点，让单体系统也逐渐淡出人们的视角，好像如果现在不用微服务架构开发项目，就与社会脱节了。好处很多，但是问题也会变得更加复杂。这节我们不讲别的，就来看看分布式事务是咋回事。

事务无论在单体还是微服务中都肯定是存在，但是在 **单体** 架构中，我们通常是怎么解决事务的呢？ `@Transactional`，单靠这个注解就可以开启事务来保证整个操作的 `原子性`。

##### 分布式事务

微服务架构，其实就是将传统的单体拆分成多个服务，然后多个服务之间相互配合，来完成业务需求。

![](https://gitee.com/cbuc/picture/raw/master/20210319130155.png)

分布式事务就是指事务的参与者，支持事务的服务器，资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。

既然说到分布式事务了，我们不妨一起了解一下微服务中的 **CAP理论**

- **C（Consistency）**：一致性。服务A、B、C三个节点都存储了用户数据，三个节点的数据都需要保持同一时刻数据一致性
- **A（Availability）**：可用性。服务A、B、C三个节点，其中一个节点如果宕机了，不能影响整个集群对外提供服务。
- **P（Partition Tolerance）**：分区容错性就是允许系统通过网络协同工作，分区容错性要解决由于网络分区导致数据的不完整及无法访问等问题。

我们都知道鱼和熊掌不可兼得，三者不能兼备择两者是也！**CAP** 目前来说无法都兼备，因此当前微服务策略中要么 `CA`，要么`CP`，不然就是`AP`。而这个时候又有一个理论出现了，那就是 **BASE理论** 。它是用来对 **CAP理论** 进行一些补充，它值得是：

- **BA（Basically Available）**：基本可用
- **S（Soft State）**：软状态
- **E（Eventually Consistent）**：最终一致性

这个理论的核心思想便是：如果我们如法做到强一致性，那么每个应用都应该根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

#### 出现场景

让我们回到分布式事务中来，什么时候会出现分布式事务呢？

**场景1：** 虽然时单体的架构服务，但由于在分库的情况下，依然会导致分布式事务的情况，因此单体服务不会出现分布式事务的这种说法，**破**~

![](https://gitee.com/cbuc/picture/raw/master/typora/20210321213920.png)

**场景2：** 分布式架构下，两个服务之间相互调用，虽然使用的是同一个数据库，但是还是会出现分布式事务。谁让你使用的是分布式架构呢~

![](https://gitee.com/cbuc/picture/raw/master/typora/20210321214255.png)

**场景3：** 分布式架构下，两个服务之间相互调用，使用的是不用的数据库，这种情况下肯定会出现分布式事务的问题，想都不用想！

![](https://gitee.com/cbuc/picture/raw/master/typora/20210321214601.png)

#### 解决方法

有问题的地方便会有方法，当然也不一定，但是在这里，分布式事务问题确实有解决的方法， 如果没有，小菜也不会写这篇文章来自讨苦吃了！

##### 方法一：全局事务

不知道这里该说 **全局事务** 会让你比较熟悉，还是 **两阶段提交（2PC）** 会让你比较熟悉，还是说都不熟悉~，不熟悉也没关系，小菜带你熟悉熟悉！

全局事务是基于DTP模型实现的，它规定了要实现分布式事务需要三种角色：

- **AP（Application）**：应用系统（微服务）

- **TM（Transaction Manager）**：