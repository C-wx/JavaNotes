大家好，我是小菜，一个渴望在互联网行业做到蔡不菜的小菜。可柔可刚，点赞则柔，白嫖则刚！
**死鬼~看完记得给我来个三连哦！**


![](https://gitee.com/cbuc/picture/raw/master/20210128204848.jpeg)


>本文主要介绍 `Java 中的异常`
>
>如有需要，可以参考
>
>如有帮助，不忘 **点赞** ❥
>
>
>微信公众号已开启，**小菜良记**，没关注的同学们记得关注哦！

`面试官`：

> 请说一下你平时比较常遇到的运行时异常

`小菜`：

> 好的，我平时比较常遇到的异常有：**NullPointException** (空指针异常) 、**ClassNotCastException** (类型转换异常) 、**IndexOutOfBoundException** (下标越界异常)，emmm.... 还有些忘记名字了~

`面试官`：

> 那你说下异常的分类吧

`小菜`：

> 异常好像是分为运行时异常和 ... ，不好意思，有点想不起来了

`面试官`：

> emm， 还有个编译时异常，那你平时写代码提示有异常是怎么处理的

`小菜`：

> 额，这个， 一般都会直接抛出异常

`面试官内心OS`： **就这水平？** 

`小菜内心OS`：**伤害性不高，侮辱性极强**

对于常年奋战在代码一线的我们来说，说几个常见异常就像让你数一下你有多少钱一样，虽然有，但是说出来不多。又很轻蔑的觉得，这什么面试题，就这？还能当面试官。但是往往这么简单的问题，你答的不好，一样能让你 **面试等通知，录取砍薪资**。

我们从吐槽中回过神来想一想，自己写的代码还没点 **x** 数吗，**异常、bug** 不就是自己的精神伴侣吗，没这点东西的支撑，自己平时怎么冠冕堂皇的划水呢！

![](https://gitee.com/cbuc/picture/raw/master/20210128210905.jpg)

是什么导致我们平时遇到的异常很多，却记不起几个。是因为实在太多了，让自己记不住吗！还是习惯了百度呢~ emmm，估计都有，小菜心虚了，赶紧奋笔，摆脱被异常支配的烦恼。电子设备面前的你，为了更有底气的回答上面那几个问题，不妨跟小菜再来复习下 `异常` 吧！

### 走进异常

异常就是有异于常态，和正常情况不一样，有错误出现。在 **Java** 中，阻止当前方法或作用域的情况，称之为异常。我们先来看下异常的结构：

![](https://gitee.com/cbuc/picture/raw/master/20210128221854.png)

**Throwable** 作为顶层父类，派生出了 **Error** 和 **Exception** 两个子类。

- `Error`：错误。Error 类以及它的子类的示例，代表了 **JVM** 本身的错误，错误不能被程序员通过代码处理，Error 一般很少出现。
- `Exception`：异常。Exception 类以及它的子类，代表程序运行时发送的各种不期望发生的时间。可以被 **Java** 异常 处理机制使用，是异常处理的核心。

我们本文重点关注 `Exception` 

**Java 的基本理念是 "结构不佳的代码不能运行"**

#### 异常使用

一个简单处理异常的例子：

```java
if(t == null){
    throw new NullPointException();
}
```

当我们需要引用对象 t，但是有可能 t 对象尚未被初始化，所以在使用这个对象之前，我们会对引用进行检查。可以创建一个代表错误信息的对象，并且将它从当前环境中 “抛出”，这样就把错误信息传播到了 “更大” 的环境中，这种称为 `抛出一个异常`。这样的好处便是当前环境下就不必再为这个问题操心了，它将会在别的地方得到处理。

##### 异常参数

异常对象与其他 **Java** 对象一样，都可以通过 `new` 关键字在 **堆上** 创建异常对象，因此，这也伴随着存储空间的分配和构造器的调用。

所有标准的异常类都有两个构造器，一个是 **默认构造器**， 一个是 **接受字符串作为参数的构造器** 这样子我们能把相关的异常信息放入异常对象的构造器中：

```java
throw new NullPointException("t 对象为空")；
```

通过这样子抛出异常，排查者也能快速的定位问题

我们还可以简单地把异常处理看成一种不同的返回机制：

![](https://gitee.com/cbuc/picture/raw/master/typora/20210201211840.png)

尽管返回的异常对象其类型与方法设计的返回类型不同，但是从效果上看，它就像从方法中返回的。

#### 异常捕获

在编写代码处理异常时，对于检查异常，有2种不同的处理方式：使用`try…catch…finally`语句块处理它；或者在函数签名中使用`throws`声明交给函数调用者去解决。

##### try 块

`try` 的译思便是 **尝试**，那么是尝试做什么呢？我们知道如果在方法内部抛出了异常（或者在方法内调用的其他方法抛出了异常），这个方法将会在抛出异常的过程中结束。我们有时候不想这么轻易结束，这个时候就用到了 **尝试** 的概念，我们可以在方法内设置一个特殊的块来捕获异常，在这个块中 **"尝试"** 各种（可能产生异常的）方法调用，所以我们将其称之为 **try 块** 。

![](https://gitee.com/cbuc/picture/raw/master/typora/20210201212958.png)

有了异常处理机制，我们可以把所有可以产生异常的动作都放进 **try 块** 里面，然后只需一个地方就可以捕获所有异常。

但是，这里特别需要注意的是，**不要滥用异常！！！** 有些人可能有点小聪明，编写了以下代码：

![](https://gitee.com/cbuc/picture/raw/master/typora/20210201221020.png)

咋看代码可以你觉得很奇怪，为什么有人会优先使用基于异常的循环，大部分会这样写的都会以为错误判断机制性能会比较高，因为 **JVM** 对每次数组访问都要检查是否越界。

注： **异常应该只用于异常的情况下，它们永远不应该用于正常的控制流，设计良好的 API 不应该强迫它的客户端为了正常的控制流而使用异常**

**Java** 中提供了三种可抛出结构（**throwable**） ： 受检异常（checked exception）、运行时异常（run-time exception）和错误（error）。我们在写代码的时候往往会有所纠结，到底该抛出何种结构？

在决定使用受检异常或者使用未受检异常的时候，我们的主要原则应该是 ：**如果期望调用者能够适当地恢复程序，这种情况下我们就应该使用受检异常**。通过抛出受检异常，我们应该在一个 **catch** 子句中处理该异常，或者将它传播出去，让调用者处理。

![](https://gitee.com/cbuc/picture/raw/master/typora/20210201225342.png)

**运行时异常** 和 **错误** 都属于 **非受检可抛出结构**。它们都是不需要也不应该被捕获的可抛出结构。当程序抛出可受检结构的时候，就意味着当前情况属于不可恢复的，如果程序没有捕捉到这样的可抛出结构，将会导致当前线程中断。

我们常用 `运行时异常` 来表明编程错误。我们实现的所有未受检抛出结构都应该是 `RuntimeException` 的子类。不应该定义 `Error` 的子类，虽然 **Java 规范** 中没有明确要求如此，但是 `Error` 往往是被 **JVM** 保留下来使用的，以表明资源不足，约束失败，或者其他使程序无法继续执行的条件。

##### 自定义异常

我们不必深陷 **Java** 已有的异常类型而无法自拔。 **Java** 提供的异常体系只是包含了基本的异常，不可能预见所有值得报告的错误。所以我们可以自己定义异常类来表示程序中可能会遇到的特定问题。

要自己定义异常类，就必须从已有的异常类中集成，最好是选择意思相近的异常类继承，但是这并不是一个简单的选择~

![](https://gitee.com/cbuc/picture/raw/master/typora/20210201225948.png)

我们上面只是简单继承了 `Exception` ，构造函数中无法传入我们想要表达的错误报告，实现这种方式也很简单，我们只需要为异常类定义一个接受字符串参数的构造器：

![](https://gitee.com/cbuc/picture/raw/master/typora/20210201230540.png)

`getMessage()` 方法有点类似于 `toString()`，可以获取异常类更加详细的信息。

